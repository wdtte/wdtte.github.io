<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Spring Transaction</title>
    <link href="/2023/08/27/SpringTransaction/"/>
    <url>/2023/08/27/SpringTransaction/</url>
    
    <content type="html"><![CDATA[<h1 id="Spring-Transaction"><a href="#Spring-Transaction" class="headerlink" title="Spring Transaction"></a>Spring Transaction</h1><h3 id="什么是事务？"><a href="#什么是事务？" class="headerlink" title="什么是事务？"></a>什么是事务？</h3><p>事务是一组关联的数据库操作，要么全部成功执行，要么全部回滚，保障了数据库操作的一致性、完整性。Spring本身没有事务，是通过集成和调用持久层实现的事务。</p><h3 id="事务的分类"><a href="#事务的分类" class="headerlink" title="事务的分类"></a>事务的分类</h3><ul><li><p><strong>编程式事务</strong></p><ul><li><p>优点：<strong>粒度更小</strong>，可以在try-catch代码块锁定精确的范围</p></li><li><p>缺点：配置繁琐、代码耦合度高</p><figure class="highlight xml"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;transactionManager&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;dataSource&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;transactionTemplate&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.transaction.support.TransactionTemplate&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;transactionManager&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;transactionManager&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs Java">transactionTemplate.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TransactionCallback</span>&lt;Object&gt;() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">doInTransaction</span><span class="hljs-params">(TransactionStatus status)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 在此处执行事务操作</span><br>            <span class="hljs-comment">// 例如，插入、更新、删除等数据库操作</span><br><br>            <span class="hljs-comment">// 如果发生异常，事务会被回滚</span><br>            <span class="hljs-comment">// 如果一切正常，事务会被提交</span><br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            <span class="hljs-comment">// 捕捉异常，标记事务为回滚状态</span><br>            status.setRollbackOnly();<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>声明式事务</strong></p><ul><li>优点：降低耦合、<strong>减少对代码的侵入性</strong>、<strong>配置简单</strong></li><li>缺点：@Transactional是方法级的、粒度更大</li></ul><p>需要在配置类&#x2F;文件中配置好 <code>DataSourceTansactionManager</code> 然后添加 <code>@EnableTransactionManagement</code> ，就可以开始使用<code>@Transactonal</code>注解了。</p></li></ul><h5 id="问题：怎么缩小声明式事务的粒度？"><a href="#问题：怎么缩小声明式事务的粒度？" class="headerlink" title="问题：怎么缩小声明式事务的粒度？"></a>问题：怎么缩小声明式事务的粒度？</h5><p>将使用事务的方法拆分成小的方法，在整个方法里面调用小方法，在小方法上添加<code>@Transactional</code>。</p><h3 id="事务的实现原理"><a href="#事务的实现原理" class="headerlink" title="事务的实现原理"></a>事务的实现原理</h3><p>Spring事务是基于AOP实现的，</p><p>对一个方法开启事务对应着用AOP将这个方法增强，使用一个around advice 首先在前置通知事务管理器在方法调用前开启事务，然后执行方法，然后在返回后通知提交事务，或者在抛出后通知回滚事务，然后再在后置通知关闭事务，rollbackfor对应着AOP的catch代码块捕获的异常。这样理解对吗？</p><h3 id="Transactional注解"><a href="#Transactional注解" class="headerlink" title="@Transactional注解"></a>@Transactional注解</h3><ul><li><p><code>@Transactional</code>是spring声明式事务的核心注解；</p></li><li><p>它可以被添加到方法上，起到事务的作用（事务的声明是方法级的）；</p></li><li><p>添加到的方法如果有<code>unchecked</code>的（没有被catch的）<code>RuntimeException</code>及其子类异常，将会触发事务回滚。（编译期异常不会触发）</p></li><li><p>如果方法里面检查了异常比如添加了try-catch代码块，将不会触发事务回滚，如果让事务能够正常回滚，则需要在catch内添加<code>TransactionAspectSupport.currentTransactionStatus().setRollbackOnly()</code>;</p></li><li><p>@Transaction的属性</p><ul><li><p><code>isolation</code> 指定当前事务的隔离级别，默认是数据库的默认隔离级别</p></li><li><p>**<code>propagation </code>**指定传播行为</p></li><li><p><code>timeOut</code> 指定事务的超时时间，单位是秒，默认值-1（没有超时时间）</p></li><li><p>**<code>readOnly </code>**默认是false，声明事务里面有读有写，改成true时，告诉数据库事务中只有读，可以做优化，提高查询效率</p></li><li><p><code>rollbackFor</code> 指定哪些异常触发回滚</p></li><li><p><code>rollbackForClass</code></p></li><li><p><code>noRollbackFor</code></p></li><li><p><code>noRollbackForClass</code></p></li></ul></li></ul><h3 id="事务的传播行为"><a href="#事务的传播行为" class="headerlink" title="事务的传播行为"></a>事务的传播行为</h3><p>事务的传播行为指的是在一个声明了事务的方法中，调用了另外一个声明了事务的方法（嵌套事务），这个时候需要设置事务的传播行为，定义在方法调用链中嵌套事务如何相互影响。</p><p><img src="https://raw.githubusercontent.com/wdtte/image/main/202308271129551.png" alt="image-20230827112927367"></p><p>事务的传播行为由<strong>propagation</strong>属性声明</p><h4 id="事务传播行为的分类"><a href="#事务传播行为的分类" class="headerlink" title="事务传播行为的分类"></a>事务传播行为的分类</h4><ul><li><p><strong>REQUIRED</strong> 方法调用时，如果调用者已经存在事务，就加入到调用者的事务，如果不存在事务，就开启一个新的事务（使用被调用者的事务）</p><img src="https://raw.githubusercontent.com/wdtte/image/main/202308271141099.png" alt="image-20230827114106992" style="zoom:50%;" /></li><li><p><strong>REQUIRES_NEW</strong> 方法调用时，将调用者的事务挂起，开启一个新的事务（使用被调用者的事务），等待新事务返回后继续原来的事务。</p><img src="https://raw.githubusercontent.com/wdtte/image/main/202308271144276.png" alt="image-20230827114443130" style="zoom:50%;" /></li><li><p><strong>NESTED</strong></p><p>开启嵌套的两个事务，调用者的事务回滚会影响被调用者，被调用者的回滚不会影响调用者的事务。 </p><img src="https://raw.githubusercontent.com/wdtte/image/main/202308271146953.png" alt="image-20230827114654851" style="zoom:50%;" /></li><li><p><strong>NEVER</strong></p><p>不允许有别的事务，否则抛异常</p></li><li><img src="https://raw.githubusercontent.com/wdtte/image/main/202308271337174.png" alt="image-20230827133700088" style="zoom: 67%;" /></li></ul><p><strong>思考：propagation属性声明在哪个位置？调用者声明还是被调用者？</strong></p><p>被调用者，被调用者根据传播行为来选择自己使用事务的方式。</p><h3 id="事务为什么会失效"><a href="#事务为什么会失效" class="headerlink" title="事务为什么会失效"></a>事务为什么会失效</h3><ul><li>没有正确配置事务、没有开启事务、没有@Transactional注解</li><li>加了@Transactional但是方法调用中使用了this，绕开了代理。？</li></ul>]]></content>
    
    
    <categories>
      
      <category>JavaEE</category>
      
      <category>spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>注解&amp;反射</title>
    <link href="/2023/08/26/%E6%B3%A8%E8%A7%A3&amp;%E5%8F%8D%E5%B0%84/"/>
    <url>/2023/08/26/%E6%B3%A8%E8%A7%A3&amp;%E5%8F%8D%E5%B0%84/</url>
    
    <content type="html"><![CDATA[<h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><h3 id="注解和注释"><a href="#注解和注释" class="headerlink" title="注解和注释"></a>注解和注释</h3><p>注释不影响代码 &amp; 注解有一些特定的功能</p><h3 id="预定义注解"><a href="#预定义注解" class="headerlink" title="预定义注解"></a>预定义注解</h3><p><strong><code>@Override</code></strong> <strong><code>@Deprated</code></strong> <strong><code>SuppressWarnings</code></strong></p><h4 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h4><p>用于定义注解的注解</p><p><strong><code>@Target</code></strong>  注解位置</p><p><strong><code>@RetentionPolicy</code></strong> 保留周期</p><p>…</p><h3 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h3><ul><li>用元注解创建自定义注解</li><li>作用：存储一个值 XXX.class.getAnnotation().xx();拿到抽象方法返回值，就是这里存储的值。<ul><li>@XXX(a&#x3D;””,b&#x3D;””)</li><li>如果恰好有一个抽象方法名字是value，注解调用的时候就不用写名字</li></ul></li></ul><h3 id="自定义注解和预定义注解的区别"><a href="#自定义注解和预定义注解的区别" class="headerlink" title="自定义注解和预定义注解的区别"></a>自定义注解和预定义注解的区别</h3><p>自定义注解不像预定义注解有一些默认的功能，自定义注解要配合反射使用，往往是在代码中直接定义一些值，这些值将在实际程序运行的时候加载和使用。</p><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><h3 id="什么是反射"><a href="#什么是反射" class="headerlink" title="什么是反射"></a>什么是反射</h3><p>反射是用代码操作代码、用面向对象诠释面向对象的一种机制&#x2F;技术。</p><p>面向对象中，所有的对象都有对应的类（除了int、char、byte…）。现在把所有的类都看作对象，那么就有描述类的类，这个类就是<code>java.lang.Class</code></p><h4 id="如何获取Class的对象"><a href="#如何获取Class的对象" class="headerlink" title="如何获取Class的对象"></a>如何获取Class的对象</h4><ul><li>类.class</li><li>对象(指通俗的对象).getClass()</li><li>Class.$forName$(“全限定类名”)</li></ul><h4 id="为什么synchronized锁旗标用当前类-class？"><a href="#为什么synchronized锁旗标用当前类-class？" class="headerlink" title="为什么synchronized锁旗标用当前类.class？"></a>为什么synchronized锁旗标用当前类.class？</h4><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassDemo2</span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * ClassDemo2.class</span><br><span class="hljs-comment">     */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">a</span><span class="hljs-params">()</span>&#123;<br>        <br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">b</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">synchronized</span>(ClassDemo2.class)&#123;<br>            <br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><img src="https://raw.githubusercontent.com/wdtte/image/main/202308260912055.png" alt="image-20230826091251008" style="zoom:50%;" /><p>把ClassDemo2看作对象，描述它的类是Class，Class的一个对象引用的地址就是这个“对象”的地址，这个“对象”只存在一个，地址只存在一个，所以不管什么时候在哪里以哪种方式获取到的都是同一个字节码对象。</p><h3 id="反射-1"><a href="#反射-1" class="headerlink" title="反射"></a>反射</h3><ul><li>获取内容<ul><li>构造方法</li><li>方法</li><li>字段</li></ul></li><li>创建对象</li><li>执行方法</li></ul><h3 id="暴力反射"><a href="#暴力反射" class="headerlink" title="暴力反射"></a>暴力反射</h3><p>getDeclaredXXX()获取到访问不到的内容（比如private修饰的构造方法、字段、方法）</p><p>但现在拿到了却没有权限使用，设置一下权限 setAccessable(true) </p><p>然后newInstance()、set()、invoke()等</p><h3 id="执行字节码文件里面的方法"><a href="#执行字节码文件里面的方法" class="headerlink" title="执行字节码文件里面的方法"></a>执行字节码文件里面的方法</h3><p>如果只拿到字节码文件，往往没有办法直接运行，用反射可以</p><p>Class.$classforName$(“字节码文件对应的全限定类名”).getXXX().invoke()等</p>]]></content>
    
    
    <categories>
      
      <category>Javase</category>
      
    </categories>
    
    
    <tags>
      
      <tag>注解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring</title>
    <link href="/2023/08/25/Spring/"/>
    <url>/2023/08/25/Spring/</url>
    
    <content type="html"><![CDATA[<p>Introduction to Spring Framework </p><span id="more"></span><h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><h3 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h3><p>Inversion Of Control，一种编程模式，将<strong>依赖关系的获取和管理转移到了容器或框架中</strong>，从而实现了组件的松耦合。</p><h3 id="ApplicationContext"><a href="#ApplicationContext" class="headerlink" title="ApplicationContext"></a>ApplicationContext</h3><p>就是管理bean的容器，ioc容器。</p><h4 id="构建context-amp-bean的方式"><a href="#构建context-amp-bean的方式" class="headerlink" title="构建context&amp;bean的方式"></a>构建context&amp;bean的方式</h4><ul><li><p><strong>ClassPathXmlApplicationContext</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> +<span class="hljs-attr">一堆命名空间</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContex</span>(<span class="hljs-string">&quot;这里面放resources目录下的配置文件路径&quot;</span>).<span class="hljs-keyword">var</span><br><span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> context.get(<span class="hljs-string">&quot;beanId&quot;</span>); <span class="hljs-comment">//&lt;T&gt; t = context.getBean(&quot;beanId&quot;,T.class);</span><br><span class="hljs-comment">//这里的实际类型就是bean的实际类型，只是用Object来接收它，所以直接打印调用的是重写的tostring</span><br><span class="hljs-comment">//默认tostring返回 getClass().getName() + &quot;@&quot; + Integer.toHexString(hashCode())，而且默认的hashCode是本地方法，根据对象的实际内存地址得到哈希码（与内容无关），如果没有哈希冲突，这个哈希码可以唯一标识对象。重写的hashCode大多都是根据内容得到哈希码，内容一样的两个对象得到一样的哈希码，比如两个值相同的字符串。</span><br></code></pre></td></tr></table></figure></li><li><p><strong>AnnotationConfigApplicationContext</strong></p><p><code>@ComponentScan(&quot;&quot;)</code></p><p><code>@Configuration</code> <code>@Bean</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">new</span> <span class="hljs-title class_">AnnotationConfigApplicationContext</span>(T.class).<span class="hljs-keyword">var</span><br></code></pre></td></tr></table></figure></li><li><p>两种可以混合使用</p><ul><li>在xml中<code>&lt;context:component-scan base-package=&quot;&quot;&gt;</code>或者<code>@ComponentScan(&quot;&quot;)</code>；然后注解创建</li><li>在配置类上<code>@ImportResource(&quot;/.../XXX.xml&quot;)</code>导入配置文件；</li></ul></li><li><p>@component</p><p>修饰在类上，context在初始化的时候就会实例化一个该类的对象放入context</p></li><li><p>集合的创建</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">util:list</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;list&quot;</span> <span class="hljs-attr">value-type</span>=<span class="hljs-string">&quot;java.lang.String&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>El1<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>El2<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>El3<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">util:list</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">util:set</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;set&quot;</span> <span class="hljs-attr">value-type</span>=<span class="hljs-string">&quot;com.wdte.bean.User&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>wdte<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>liys<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>publishBy<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">util:set</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">util:map</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;map&quot;</span> <span class="hljs-attr">key-type</span>=<span class="hljs-string">&quot;java.lang.String&quot;</span> <span class="hljs-attr">value-type</span>=<span class="hljs-string">&quot;com.wdte.bean.Note&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;note-1&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;note1&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">util:map</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这里还需要注册类型转换器把id转成实际的bean</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs xml">import org.springframework.core.convert.converter.Converter;<br><br>public class StringToUserConverter implements Converter&lt;String, User&gt; &#123;<br>    @Override<br>    public User convert(String source) &#123;<br>        // 在这里执行将字符串转换为User对象的逻辑<br>        // 例如，根据字符串查询数据库获取User对象<br>        // 然后返回User对象<br>    &#125;<br>&#125;<br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;conversionService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.context.support.ConversionServiceFactoryBean&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;converters&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">set</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.example.StringToUserConverter&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">set</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="DI"><a href="#DI" class="headerlink" title="DI"></a>DI</h3><p>Dependency Injection，一种特殊的赋值，通过外部的方式将一个对象的依赖关系注入到该对象中，而不是由该对象自己去创建或获取依赖对象。（解耦）</p><ul><li><strong>构造方法</strong>注入 <code>&lt;constructor-arg name=&quot;&quot; value=&quot;&quot;/&gt;</code></li><li><strong>setter方法</strong>注入（通过外部文件如yaml就是这种方式） <code>&lt;property name=&quot;&quot; value=&quot;&quot;/&gt;</code></li><li>注解注入 <code>@Component</code>，需要开启包扫描<code>@ComponentScan()</code> ||  <code>&lt;context:component-scan base-package=&quot;&quot;&gt;</code></li><li><ul><li>构造方法和setter方法可以混用，因为默认空参构造</li><li>前两种方法的赋值如果传入的不是基本类型，value变ref，引用context中已有的bean</li><li>使用工厂模式的<strong>工厂方法创建</strong>的bean首先要创建工厂实例，然后用<code>factory-bean=“”</code>传入工厂实例和<code>factory-mothod</code>指定工厂方法，然后嵌套<code>&lt;constructor-arg/&gt;</code>传构造方法参数</li></ul></li></ul><p>bean标签是创建bean，里面嵌套的赋值是DI；自动装配是为了更灵活地DI</p><p>特殊的有集合bean的创建和DI，还需要引入命名空间</p><h3 id="AutoWiring"><a href="#AutoWiring" class="headerlink" title="AutoWiring"></a>AutoWiring</h3><p><strong>无需显式指定依赖关系</strong></p><p>在Spring框架中，自动装配（Autowiring）是一种通过Spring容器自动将组件之间的依赖关系建立起来的机制。通过自动装配，您可以告诉Spring框架，哪些组件需要依赖哪些其他组件，而Spring会在运行时自动将这些依赖关系满足。</p><p>自动装配可以通过注解或XML配置来实现，最常用的方式是使用注解。</p><p>要是没有自动装配，需要用户对每个bean的字段一个一个手动赋值，复杂类型的用ref属性引用已经存在的bean</p><p>有了自动装配，就不用手动赋值了。配置文件的所有自动装配都不能装配简单类型(包括String、Integer…)</p><p><strong>自动装配的类型</strong>：</p><ul><li><p><strong>byName：</strong>在context里面找到<code>beanId</code>和字段名一样的bean并赋值</p><p>​需要保证<code>beanId</code>唯一性，并且如果有多个类型不一样的bean使用同一个id会类型转换错误</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs xml">    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;publishBy&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.wdte.bean.User&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;publish User&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;age&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;18&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;content&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;java.lang.String&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Hello World&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;note1&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.wdte.bean.Note&quot;</span> <span class="hljs-attr">autowire</span>=<span class="hljs-string">&quot;byName&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;1&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br>@Data<br>@NoArgsConstructor<br>@AllArgsConstructor<br>public class Note &#123;<br>    private Integer id;<br>    private String content;<br>    private User publishBy;<br>&#125;<br>@Data<br>@NoArgsConstructor<br>@AllArgsConstructor<br>public class User &#123;<br>    private String name;<br>    private int age;<br>&#125;<br><br>这里content不会被自动装配<br></code></pre></td></tr></table></figure></li><li><p><strong>byType：</strong>在context里面找到该类型的唯一一个实例并赋值</p><p>要么有一个该类型实例要么没有，没有或者有多个会报错</p></li><li><p><strong>构造方法（constructor）</strong></p><ol><li><p>首先byType再byName</p></li><li><p>使用了autowire&#x3D;”constructor”属性，实例化这个对象的时候就会 根据需要的 DI 在提供的构造方法中<strong>选择合适的构造方法</strong>实例化</p></li><li><p>如果 被选中的构造方法中包含一个找不到的形参（此时context中没有该类型的bean||有多个该类型的bean）就会报错</p></li><li><p>没有被构造方法参数列表包含的字段会被设为字段类型的默认值</p></li></ol></li><li><p><strong>自定义自动装配（custom）</strong>：通过实现<code>BeanFactoryPostProcessor</code>接口，可以自定义自动装配逻辑。</p></li><li><p><strong>无自动装配</strong></p></li></ul><p><strong>通过注解声明自动装配方式</strong>：</p><p><strong><code>@Autowired</code></strong> byType</p><p><strong><code>@Resource</code></strong> byName</p><p><strong><code>@Autowired</code></strong> + **<code>@Qualifier</code> **byType产生歧义时，@Qualifier(“”) 传入name</p><p>可以这样使用：@Service将service层的实现类放入context，自动装配用接口类型接收，接口有多个实现时，用@Qualifier(“”) 指定beanId，或者在其中一个实现类上标记@Primary，首选实现。</p><p><strong>构造方法：</strong>如果一个类只有一个构造方法，并且该构造方法的参数在Spring容器中有对应的组件，那么Spring会自动将这些参数注入到构造方法中，即使构造方法上没有显式使用<code>@Autowired</code>注解。</p><p>对象在实例化的时候就会传参引入依赖，这种做法更保险，但是还是要根据实际需求选择自动装配的方式。</p><p>自动装配简化了Spring应用程序的配置，提高了代码的可维护性和可读性。然而，在使用自动装配时，需要谨慎处理好依赖关系，避免出现不清晰的情况，以确保应用程序的正确性。</p><p><strong><code>@Value()</code></strong> 注入简单类型 <code>“”</code>、外部配置文件<code>$&#123;&#125;</code>、别的实例的属性值和<code>spEL</code> <code>#&#123;&#125;</code></p><p><strong>bean在 DI 和 自动装配时的先后顺序</strong></p><p> <code>场景</code> 如果A类中需要 DI 一个B类类型的字段 结果 A在进行DI时 B还没有注入到IOC容器</p><p><code>解决方案</code> Spring 在设计之初考虑到这个问题 会尽可能的分析依赖关系 先从最下层的依赖bean创建并放入IOC容器 然后逐级向上创建对象并进行DI 然而 这并不稳妥 Spring只是尽可能做到这个事情 </p><p>Spring团队也考虑到这个问题 在bean标签上提供了 depends-on 属性 方便我们声明依赖关系 Spring 得到这个依赖关系的树状图后 会先从最底层的bean开始创建并进行DI</p><h4 id="DI-amp-Autowring方式对比"><a href="#DI-amp-Autowring方式对比" class="headerlink" title="DI&amp;Autowring方式对比"></a>DI&amp;Autowring方式对比</h4><table><thead><tr><th>配置类 @Configuration</th><th>@Component</th></tr></thead><tbody><tr><td>将一个对象注入到IOC容器</td><td>将一个对象注入到IOC容器</td></tr><tr><td>@Bean注解注在方法上</td><td>@Component注解在类上 当前类的一个实例会被放入IOC</td></tr><tr><td>自己new 或者 new完set</td><td>@Value + @Autowired + @Resource</td></tr><tr><td>调用被@Bean注解修饰的方法</td><td>@Autowired + @Resource 自动装配</td></tr><tr><td>往往在注入其他人或者开源团队写好的代码中的对象到IOC容器中</td><td>往往是注入自己的一个类的对象到IOC容器中</td></tr></tbody></table><p>@Resource是JavaEE规范提供的，不是spring的注解，在别的框架也可以用。</p><p>@Resource主要是byName的装配，更适合字段装配；@Autowred主要是byType的装配，不太适合但是可以用在字段上。</p><h4 id="Value"><a href="#Value" class="headerlink" title="@Value"></a>@Value</h4><p><code>@Value</code> 是 Spring 框架中的一个注解，用于将值注入到 Spring 管理的 bean 中的属性中。这允许你在配置文件中指定值，然后在代码中使用这些值，从而实现了配置和代码的分离。<code>@Value</code> 注解可以用于字段、方法、构造函数参数和方法参数上。</p><p>在注入值时，<code>@Value</code> 可以用于以下不同的场景：</p><ol><li><p><strong>注入简单值：</strong> 你可以使用 <code>@Value</code> 注解将一个简单的值（如字符串、数字等）注入到属性中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Value(&quot;Hello, Spring!&quot;)</span><br><span class="hljs-keyword">private</span> String greeting;<br></code></pre></td></tr></table></figure></li><li><p><strong>注入属性值：</strong> 你可以使用 <code>@Value</code> 注解来注入其他 bean 的属性值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Value(&quot;#&#123;otherBean.property&#125;&quot;)</span><br><span class="hljs-keyword">private</span> String someProperty;<br></code></pre></td></tr></table></figure></li><li><p><strong>注入外部配置：</strong> <code>@Value</code> 可以用来注入外部配置文件（如 properties 文件）中的属性值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Value(&quot;$&#123;app.url&#125;&quot;)</span><br><span class="hljs-keyword">private</span> String appUrl;<br></code></pre></td></tr></table></figure></li><li><p><strong>SpEL 表达式：</strong> 你还可以使用 Spring 表达式语言（SpEL）来计算属性值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">‘xxxxxxxxxx2 <span class="hljs-number">1</span><span class="hljs-meta">@Value(&quot;#&#123; T(java.lang.Math).PI * 2 * radius &#125;&quot;)</span>2private <span class="hljs-type">double</span> circumference;java<br></code></pre></td></tr></table></figure></li></ol><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><ul><li><p><strong>Singleton</strong></p><p>默认的作用域</p><p>跟随context被实例化而被实例化，销毁而销毁。生命周期由context管理</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;mySingletonBean&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.example.MySingletonBean&quot;</span> <span class="hljs-attr">scope</span>=<span class="hljs-string">&quot;singleton&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- Bean properties and configuration --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p><strong>Prototype</strong></p><p>每次获取时创建一个新的bean，需要调用者手动销毁。context不负责管理它的生命周期</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">import</span> javax.annotation.PreDestroy;<br><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Scope(&quot;prototype&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">User</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-comment">// Bean properties and methods</span><br><br>    <span class="hljs-meta">@PreDestroy</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">destroy</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// Perform cleanup or resource release here</span><br>        System.out.println(<span class="hljs-string">&quot;User Bean is being destroyed&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>Request</strong></p><p>每次http请求创建一个新的实例，请求结束销毁。</p></li><li><p><strong>Session</strong></p><p>每个用户会话创建一个新的实例，会话结束销毁。</p></li><li><p>…</p></li></ul><p><strong>Singleton和Prototype对比</strong></p><table><thead><tr><th align="center"></th><th><strong>Singleton</strong></th><th><strong>Prototype</strong></th></tr></thead><tbody><tr><td align="center">创建时机</td><td>在应用程序上下文启动时创建</td><td>在每次请求或获取时创建</td></tr><tr><td align="center">实例重用</td><td>是，每次请求或获取时返回同一个实例</td><td>否，每次请求或获取时返回新的实例</td></tr><tr><td align="center">生命周期</td><td>与应用程序上下文相同</td><td>由调用者负责管理和销毁</td></tr><tr><td align="center">线程安全性</td><td>需要保证线程安全</td><td>不用保证线程安全，每个实例在单独的线程中使用</td></tr><tr><td align="center">依赖注入</td><td>可以被其他Bean注入依赖</td><td>可以被其他Bean注入依赖，但每次注入的都是新实例</td></tr><tr><td align="center">适用场景</td><td>适用于状态无关、共享数据的Bean</td><td>适用于每次请求需要新的实例或状态相关的Bean</td></tr><tr><td align="center">Spring容器管理</td><td>是，由Spring容器负责创建和销毁</td><td>否，由调用者负责管理和销毁</td></tr></tbody></table><h4 id="Singleton的懒加载"><a href="#Singleton的懒加载" class="headerlink" title="Singleton的懒加载"></a>Singleton的懒加载</h4><p><code>@Lazy</code> 或者 <code>lazy-init=&quot;true&quot;</code> 会让singleton作用域的bean懒加载，即：需要使用时再实例化。</p><p>与prototype不同的是，实例化后一直在context中，生命周期由context管理。</p><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>由实例化、赋值、初始化、使用、销毁几个阶段组成</p><ul><li><p><strong>实例化</strong>：contructor&#x2F;factory方法实例化创建bean</p></li><li><p><strong>赋值</strong>：setter方法（<property>标签）注入依赖 赋值</p></li><li><p><strong>初始化</strong>：</p><ul><li>后置处理器前置初始化方法（需要BeanPostProcessor类型的实例，有一个实例所有的bean都会有这个周期）</li><li><strong>初始化前回调方法</strong> 实现InitializingBean接口，实现afterPropertiesSet方法</li><li>自定义初始方法 init-mothod指定自定义初始方法</li><li>后置处理器后置初始化方法（BeanPostProcessor）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@Bean</span><br>    BeanPostProcessor <span class="hljs-title function_">beanPostProcessor</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanPostProcessor</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">postProcessBeforeInitialization</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>                System.out.println(<span class="hljs-string">&quot;这是后置处理器前置初始化方法from &quot;</span>+beanName);<br>                <span class="hljs-keyword">return</span> bean;<br>            &#125;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">postProcessAfterInitialization</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>                System.out.println(<span class="hljs-string">&quot;这是后置处理器后置初始化方法from &quot;</span>+beanName);<br>                <span class="hljs-keyword">return</span> bean;<br>            &#125;<br>        &#125;;<br>    &#125;<br>这是后置处理器前置初始化方法from org.springframework.context.event.internalEventListenerProcessor<br>这是后置处理器后置初始化方法from org.springframework.context.event.internalEventListenerProcessor<br>这是后置处理器前置初始化方法from org.springframework.context.event.internalEventListenerFactory<br>这是后置处理器后置初始化方法from org.springframework.context.event.internalEventListenerFactory<br>这是后置处理器前置初始化方法from abean<br>Properties seted!<br>这是后置处理器后置初始化方法from abean<br>这是后置处理器前置初始化方法from bbean<br>这是后置处理器后置初始化方法from bbean<br><span class="hljs-title function_">abeanAbean</span><span class="hljs-params">(field1=<span class="hljs-number">1</span>, field2=<span class="hljs-number">2</span>, field3=<span class="hljs-number">3</span>)</span><br>bbeanBbean(field1=<span class="hljs-number">4</span>, field2=<span class="hljs-number">5</span>)<br></code></pre></td></tr></table></figure></li><li><p><strong>使用</strong>：getBean方法获取使用bean</p></li><li><p><strong>销毁</strong>：</p><ul><li>销毁前回调方法 @Destroy 方法标记方法</li><li>自定义销毁方法 DisposableBean接口desdroy方法</li><li>context销毁bean</li></ul></li></ul><h3 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h3><p>Aspected Oriented Programming，一种编程思想；</p><p>通过预编译和运行期间<strong>动态代理</strong>实现程序功能统一维护的一种技术；</p><p>AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。AOP是OOP的延续。</p><p><strong>可以做到在不修改原来的代码的情况下增加业务</strong></p><ul><li><p><strong>切面Aspect</strong></p><p>创建切面类@Aspect标记</p></li><li><p><strong>切点Cutpoint</strong></p><p>用表达式声明拦截哪些方法</p></li><li><p><strong>连接点JoinPoint</strong></p><p>向增强方法传的参数</p></li><li><p><strong>通知Advice</strong></p><ul><li>@Before</li><li>@After</li><li>@AfterReturning</li><li>@AfterThrowing</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/wdtte/image/main/202308252322188.png" alt="image-20230825232217759"></p><h3 id="Dynamic-Proxying"><a href="#Dynamic-Proxying" class="headerlink" title="Dynamic Proxying"></a>Dynamic Proxying</h3><p>Aop 实现原理</p><h3 id="Transaction-TX"><a href="#Transaction-TX" class="headerlink" title="Transaction (TX)"></a>Transaction (TX)</h3><p>Aop的应用</p><h3 id="循环依赖"><a href="#循环依赖" class="headerlink" title="循环依赖"></a>循环依赖</h3><p>循环依赖（Circular Dependency）是指两个或多个类之间存在相互依赖关系的情况，从而形成了一个闭环。这种情况下，每个类都依赖于另一个类，导致无法在不出现问题的情况下正确地创建这些类的实例。循环依赖可能会导致程序运行时的错误、死锁、性能问题以及代码难以理解和维护。</p><p>在软件开发中，循环依赖是应该避免的，因为它们可能会引发一系列问题。下面是一些关于循环依赖的问题和解决方法：</p><p><strong>问题：</strong></p><ol><li><p><strong>无法正确实例化：</strong> 当两个或多个类互相依赖时，创建它们的实例可能会导致死循环或栈溢出，从而无法成功初始化这些类。</p></li><li><p><strong>不稳定性：</strong> 循环依赖可能导致对象的状态不稳定。因为循环依赖可能会导致对象的构造和初始化过程交织在一起，使得对象的状态在不同步骤中发生变化。</p></li><li><p><strong>难以理解和维护：</strong> 循环依赖会增加代码的复杂性，使代码难以理解和维护。代码中出现循环依赖会使得类之间的关系变得混乱，增加了调试和修改的困难。</p></li></ol><p><strong>解决方法：</strong></p><ol><li><p><strong>设计调整：</strong> 重新考虑类之间的依赖关系，看是否可以进行逻辑上的调整，以减少循环依赖。</p></li><li><p><strong>引入中间层：</strong> 可以考虑引入一个中间层或接口来隔离循环依赖，从而将直接依赖转变为间接依赖。</p></li><li><p><strong>使用延迟初始化：</strong> 在 Spring 等容器中，可以使用延迟初始化（Lazy Initialization）来解决循环依赖问题。容器会在需要时才创建对象，从而避免了循环依赖导致的初始化问题。</p></li><li><p><strong>使用构造函数注入：</strong> 在 Spring 中，使用构造函数注入可以降低循环依赖的风险。构造函数注入在对象创建时就完成了依赖的注入，避免了后续初始化过程中的问题。</p></li></ol><p>总的来说，循环依赖是一种应该尽量避免的情况，因为它会引发一系列问题。在设计和编写代码时，需要注意依赖关系，以确保类之间的依赖关系清晰，避免出现循环依赖。</p><h3 id="需要包扫描的注解"><a href="#需要包扫描的注解" class="headerlink" title="需要包扫描的注解"></a>需要包扫描的注解</h3><ol><li><strong>@Component 及其衍生注解：</strong> 包括 <code>@Component</code>、<code>@Service</code>、<code>@Repository</code> 和 <code>@Controller</code> 注解，用于定义组件类。这些注解通常被用来标记需要被Spring容器管理的类。</li><li><strong>@Configuration：</strong> 用于定义配置类，其中包含了Spring Bean的定义和配置信息。</li><li><strong>@RestController 和 @Controller：</strong> 用于定义Web控制器类。</li><li><strong>@Service：</strong> 用于定义业务逻辑的服务类。</li><li><strong>@Repository：</strong> 用于定义数据访问对象（DAO）类。</li><li><strong>@Autowired 和 @Inject：</strong> 用于自动装配Bean依赖。</li><li><strong>@Value：</strong> 用于属性注入，允许将外部属性值注入到Bean的字段或方法参数中。</li><li><strong>@Aspect：</strong> 用于定义切面，通常与AOP一起使用。</li><li><strong>自定义注解：</strong> 如果您定义了自己的注解，并希望通过在类上使用这些注解来标记特定的类，那么您需要进行包扫描以使Spring能够发现这些标记的类</li></ol>]]></content>
    
    
    <categories>
      
      <category>JavaEE</category>
      
      <category>spring</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java Api</title>
    <link href="/2023/08/01/Java%20Api/"/>
    <url>/2023/08/01/Java%20Api/</url>
    
    <content type="html"><![CDATA[<p>常用Java Api介绍</p><span id="more"></span><h1 id="API"><a href="#API" class="headerlink" title="API"></a>API</h1><h2 id="java-lang-System"><a href="#java-lang-System" class="headerlink" title="java.lang.System"></a><code>java.lang.System</code></h2><ul><li><code>arraycopy(src,srcPos,des,drsPos,len)</code></li><li><code>currentTimeMillis()</code></li><li><code>exit()</code></li></ul><h2 id="java-util-Arrays"><a href="#java-util-Arrays" class="headerlink" title="java.util.Arrays"></a><code>java.util.Arrays</code></h2><h3 id="APi"><a href="#APi" class="headerlink" title="APi"></a>APi</h3><ul><li><p><strong><code>fill()</code></strong></p><p>全部填充 <code>void fill(T[] arr, T val)</code> 遍历赋值</p><p>部分填充 <code>void fill(T[] arr, from, to , T val)</code> 判断是否下标越界、再遍历赋值</p><p><code>rangeCheck(arr.length,from,to)</code></p></li><li><p><strong><code>toString()</code></strong></p><p>重写<code>Object.toString()</code></p><p>不是空引用、长度不为0，用StringBuilder拼接为[,,,,]字符串</p></li><li><p><strong><code>equals()</code></strong></p><p>和Object的equals()方法没有关系，只是名字一样（这里的equlas是静态的，Object的是非静态的）</p><p><strong>什么内容不可以被继承？还有 静态？内部类？static？final？复习这里！</strong></p><p>全部一样返回true 对于引用类型，首先比较地址（是否一样 是否为空），（再比较长度），地址一样再比较内容</p></li><li><p><strong><code>copyOf()</code></strong></p><p><code>type[] arr = copyOf(type[] original, int newLength)</code> 拷贝指定长度到新创建的一个数组</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs Java">type[] copy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">type</span>[newLength];<br>System.arrayCopy(original,<span class="hljs-number">0</span>,copy,<span class="hljs-number">0</span>,Math.min(original,newLenth));<br><span class="hljs-keyword">return</span> copy<br></code></pre></td></tr></table></figure></li><li><p><strong><code>copyOfRange()</code></strong></p><p><code>copyOfRange(type[] original, int from, int to)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-type">int</span> <span class="hljs-variable">newLength</span> <span class="hljs-operator">=</span> to - from;<br><span class="hljs-keyword">if</span>(newLength &lt; <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IlligalArgumentException</span>(<span class="hljs-string">&quot;...&quot;</span>);<br>type[] copy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">type</span>[newLength];<br>System.arrayCopy(original,from,copy,<span class="hljs-number">0</span>,Math.min(original.length-from,newLength));<br><span class="hljs-keyword">return</span> copy;<br></code></pre></td></tr></table></figure><p>比如：original的长度为10，当copyOfRange(original,5,12)时，newLength会大于original.length-from，为了不下标越界所以Math.min()。新数组会长一些</p></li><li><p><strong><code>binarySearch()</code></strong></p></li><li><p><strong><code>stream()</code></strong></p></li><li><p><strong><code>sort()</code></strong></p></li></ul><p><strong>深拷贝？浅拷贝？</strong></p><h3 id="比较器"><a href="#比较器" class="headerlink" title="比较器"></a>比较器</h3><p>引用类型的比较</p><p><strong>什么时候用外部 什么时候用内部？</strong></p><p>只有一种比较规则的时候用内部，需要有多种比较规则进行比较就要定义多个外部比较器</p><h4 id="内部比较器"><a href="#内部比较器" class="headerlink" title="内部比较器"></a>内部比较器</h4><p><code>java.long.comparable</code></p><p>实现该接口，实现一个<code>compareTo()</code>方法 将比较的逻辑写在了被比较的类的内部，所以叫内部比较器</p><h4 id="外部比较器"><a href="#外部比较器" class="headerlink" title="外部比较器"></a>外部比较器</h4><p><code>java.util.Comparator</code></p><p>实现该接口，实现一个<code>compare()</code>方法</p><h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><p>排序时基于比较的</p><p><code>Arrays.sort()</code>，需要一个比较器，要么内部要么外部，如果单参并且传入的实例的类没有定义相关的内部比较器就会报错。</p><p><code>java.lang.ClassCastException: module.Person cannot be cast to java.lang.Comparable</code></p><h2 id="java-lang-CharSequence"><a href="#java-lang-CharSequence" class="headerlink" title="java.lang.CharSequence"></a>java.lang.CharSequence</h2><p><img src="https://raw.githubusercontent.com/wdtte/image/main/202308211513927.png" alt="image-20230821151358855"></p><p><img src="https://raw.githubusercontent.com/wdtte/image/main/202308211515400.png" alt="image-20230821151532350"></p><h3 id="String"><a href="#String" class="headerlink" title="String"></a><code>String</code></h3><p>value[]</p><p>char类型默认值是空格？还是‘\0’</p><h4 id="多种构造方法："><a href="#多种构造方法：" class="headerlink" title="多种构造方法："></a>多种构造方法：</h4><ul><li><code>String()</code> 没有字符的字符串</li><li><code>String(String s)</code></li><li><code>String(char[] c)</code> 字符数组构建到字符串</li><li><code>String(char[] c, int offset, int count)</code> 字符数组的部分</li><li>… byte[]</li></ul><h4 id="两种方式创建："><a href="#两种方式创建：" class="headerlink" title="两种方式创建："></a>两种方式创建：</h4><ul><li><p>字面量值：将一个值以特定的格式直接定义在代码中</p><p>比如：<code>‘c’</code>, <code>“kkkkk”</code> ,<code>010（八进制）</code></p></li><li><p>构造方法</p></li></ul><p><strong>区别：</strong></p><ul><li><p><strong>字面量：</strong></p><p>因为“hello”第一次被创建的时候是在字符串常量池创建，后续创建的时候会先去常量池找 如果已经存在，就直接引用这个地址，否则再在常量池创建新的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-type">String</span> <span class="hljs-variable">str1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hello&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">str2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hello&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">str3</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;world&quot;</span>;<br><br>str1 == str2 -&gt; <span class="hljs-literal">true</span><br>str2 == str3 -&gt; <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure></li></ul><img src="https://raw.githubusercontent.com/wdtte/image/main/202308211546184.png" alt="image-20230821154651880" style="zoom:33%;" /><ul><li><p><strong>构造方法：</strong></p><img src="https://raw.githubusercontent.com/wdtte/image/main/202308211559684.png" alt="image-20230821155932566" style="zoom:33%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">str1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br><span class="hljs-type">String</span> <span class="hljs-variable">str2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br><span class="hljs-type">String</span> <span class="hljs-variable">str3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;world&quot;</span>);<br></code></pre></td></tr></table></figure></li></ul><h4 id="Api"><a href="#Api" class="headerlink" title="Api"></a>Api</h4><p><a href="E:\复习\Api\27_API_java.lang.String\资料及素材\java.lang.String.pdf">java.lang.String.pdf</a> </p><table><thead><tr><th align="center"></th><th></th><th></th></tr></thead><tbody><tr><td align="center"><code>charAt()</code></td><td></td><td></td></tr><tr><td align="center"><code>indexOf()</code></td><td></td><td></td></tr><tr><td align="center"><code>lastIndexOf()</code></td><td></td><td></td></tr><tr><td align="center">…</td><td></td><td></td></tr></tbody></table><p><code>equals</code></p><ol><li>比较地址 一样:true 否则false</li><li>地址不一样 检查参数类型是否是String,是String转为String 否则false</li><li>类型正确 比较字符数组长度 不一样:false</li><li>长度一样 逐个元素比较（whilen–遍历） 遇到不一样的:false</li></ol><p>字符串常量，<strong>不可变</strong> <code>private final char value[];</code> 一旦进行修改就是创建了新的实例，以前的没有被引用的实例就会被gc。<strong>final</strong></p><p><img src="https://raw.githubusercontent.com/wdtte/image/main/202308212224142.png" alt="image-20230821200823746"></p><h3 id="StringBuillder"><a href="#StringBuillder" class="headerlink" title="StringBuillder"></a><code>StringBuillder</code></h3><p>字符串变量，还有<code>StringBuffer</code></p><p>value[], int count </p><p>value[]没有被final修饰</p><h4 id="多种构造方法"><a href="#多种构造方法" class="headerlink" title="多种构造方法"></a>多种构造方法</h4><ul><li><p><code>StringBuider()</code></p><p>super(16) -&gt; (AbstractStringBuilder) new char[16]</p></li><li><p><code>StringBuilder(int capacity)</code></p><p>super(capacity) -&gt; new char[capacity]</p></li><li><p><code>StringBuilder(String s)</code></p><ul><li>初始化一个容量为16+s.length()的StringBuilder</li><li>将字符串append进去</li></ul></li></ul><p>为什么return this？方便多次拼接 级联调用 （返回的是同一个地址）</p><p>所以</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br><span class="hljs-type">StringBuilder</span> <span class="hljs-variable">append</span> <span class="hljs-operator">=</span> sb.append(<span class="hljs-string">&quot;hello&quot;</span>).append(<span class="hljs-string">&quot; &quot;</span>).append(<span class="hljs-string">&quot;world&quot;</span>);<br><span class="hljs-type">boolean</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> sb == append; <span class="hljs-comment">//b=true</span><br></code></pre></td></tr></table></figure><ul><li><code>StringBuilder(Charsquence c)</code></li></ul><h4 id="Api-1"><a href="#Api-1" class="headerlink" title="Api"></a>Api</h4><ul><li>追加</li><li>插入</li><li>delete()</li><li>。。。</li></ul><h4 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h4><ul><li><p>通过构造方法<code>StringBuilder(String str)</code>或者<code>StringBuilder(Charsequence c)</code>创建时，初始容量（capacity、value.length）是16+str.length() 或 16+c.length()</p></li><li><p>通过无参构造方法创建的StringBuilder的初始容量（capacity、value.length()）是16，或者用另外一个单参构造方法指定初始容量后；在每次调用append(String str)方法追加字符串时，如果容量足够容纳增加后的字符串，不会扩容，如果不够，将会扩大到<strong>原来容量</strong>的两倍再加2（jdk8是value.length&lt;&lt;1+2，左移一位再加2）</p><p>会经历以下步骤：</p><ul><li><p>super.append(str);return this; </p><p>在AbstractStringBuilder中，append方法：</p><ul><li><p>if(str &#x3D;&#x3D; null) return appendNull();</p></li><li><p>int len &#x3D; str.length()</p></li><li><p>ensureCapacityInternal(len + count)</p><p>ensureCapacityInternal(minCapacity)方法：</p><ul><li><p>if(minCapacity - value.length &gt; 0)value &#x3D; Arrays.copyOf(value,newCapacity(minCapacity));</p><p>newCapacity()方法：</p><ul><li>newCapacity &#x3D; (<strong>value.length</strong> &lt;&lt; 1) + 2; &#x2F;&#x2F;位运算，(依次向左移动一位)相当于*2然后+2 这样效率更高。。。还有一些实现省略了</li></ul></li></ul></li><li><p>str.getChars(0,len,value,count)</p><p>getChars(srcBegin,srcEnd,des,desBegin)方法：</p><ul><li>如果srcBegin&lt;0, srcBegin&gt;srcEnd, srcEnd&gt;len 引发对应的异常</li><li>System.arraycopy(value,0,des,count,srcEnd-srcBegin)      [这里的value是String类的value]</li></ul></li><li><p>count+&#x3D;len</p></li><li><p>return this;</p></li></ul></li></ul></li></ul><p><strong>什么时候使用StringBuilder什么时候String？</strong></p><p>高频率拼接，比如在一个for循环里面，使用StringBuilder</p><p>Object.toString()使用的String，Arrays.toString使用的StringBuilder</p><h2 id="JDK8时间"><a href="#JDK8时间" class="headerlink" title="JDK8时间"></a><code>JDK8时间</code></h2><p>不用java.util.Date…（老版本）</p><p><strong><code>java.time.*</code></strong>     <code>java.time.Year</code>, <code>java.time.YearMonth</code>, <code>java.time.MonthDay</code>, <code>java.time.LocalDate</code> <code>java.time.LocalTime</code> <code>java.time.LocalDateTime</code></p><p>构造方法私有化，不能直接实例化，用<code>now()</code>等方法创建</p><ul><li>static now() 获取当前时间</li><li>static of() 获取指定时间的时间</li><li>atXXX() 拼接</li><li>比较<ul><li>比较器</li><li>isBefore() isAfter() equals</li></ul></li><li>getXXX()</li><li>isLeapYear()</li><li>minusXXX(), plusXXX(), addXXX()</li></ul><h4 id="转换-amp-还原"><a href="#转换-amp-还原" class="headerlink" title="转换&amp;还原"></a>转换&amp;还原</h4><p>format(DateTimeFomatter.ofParttern(),java.time.*)</p><p>parse(str,DateTimeFormatter.ofParttern())</p><p>java.time.* &lt;–&gt; timeMillis</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-type">long</span> <span class="hljs-variable">timeMillis</span> <span class="hljs-operator">=</span> <span class="hljs-number">1629638400L</span>;<br>LocalDateTime.ofInstant(Instant.ofEpochSeconds(timeMillis),ZoneId.systemDefault());<br>Instant是一个精确到纳秒级别的时间点，与时区无关。<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">localDateTime</span> <span class="hljs-operator">=</span> LocalDateTime.of(<span class="hljs-number">2024</span>,<span class="hljs-number">10</span>,<span class="hljs-number">1</span>,<span class="hljs-number">8</span>,<span class="hljs-number">30</span>,<span class="hljs-number">26</span>);<br><span class="hljs-type">long</span> <span class="hljs-variable">timeMillis</span> <span class="hljs-operator">=</span> localDateTime(localDateTime.atZone(ZoneId.systemDefault()));<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/wdtte/image/main/202308221818070.png" alt="image-20220829201947889"></p>]]></content>
    
    
    <categories>
      
      <category>Javase</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Api</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java创建线程的四种方法</title>
    <link href="/2023/04/13/Java%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%96%B9%E6%B3%95/"/>
    <url>/2023/04/13/Java%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>四种方法包括：实现Runnable接口实现run ()方法、继承Thread类重写run()方法、实现Callable接口实现call()方法、由线程池通过submit() | execute() 方法创建</p><span id="more"></span><h3 id="Java创建线程的四种方法"><a href="#Java创建线程的四种方法" class="headerlink" title="Java创建线程的四种方法"></a>Java创建线程的四种方法</h3><h4 id="1-实现Runnable接口"><a href="#1-实现Runnable接口" class="headerlink" title="1. 实现Runnable接口"></a>1. 实现<code>Runnable</code>接口</h4><p>创建一个类实现<code>Runnable</code>接口，实现<code>run()</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread1</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(Thread.currentThread().getName());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>实例化一个该类的对象传入<code>Thread()</code>构造方法，通过创建的thread对象调用<code>start()</code>方法就开启了该线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">thread1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread1</span>());<br>    thread1.start();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-继承Thread类"><a href="#2-继承Thread类" class="headerlink" title="2. 继承Thread类"></a>2. 继承<code>Thread</code>类</h4><p>创建一个类继承<code>Thread</code>类，重写<code>run()</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(Thread.currentThread().getName());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>实例化一个该类的对象传入<code>Thread()</code>构造方法，通过创建的thread对象调用<code>start()</code>方法就开启了该线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">thread2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread2</span>());<br>    thread2.start();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-实现-Callable接口"><a href="#3-实现-Callable接口" class="headerlink" title="3.实现 Callable接口"></a>3.实现 <code>Callable</code>接口</h4><p>创建一个类实现<code>Callable</code>接口，实现<code>call()</code>方法</p><p><code>call()</code>方法是有返回值的，所以这种方法用来创建有返回值的线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread3</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Callable</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.println(Thread.currentThread().getName());<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello World&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>实例化一个该类的对象传入<code>FutureTask&lt;&gt;()</code>构造方法，创建一个<code>FutureTask&lt;&gt;</code>类型的对象，将该对象传入<code>Thread()</code>构造方法，调用<code>start()</code>方法就开启了该线程（泛型是返回值的类型）</p><p>通过上面创建的<code>FutureTask&lt;&gt;</code>类型的对象调用<code>get()</code>方法可以拿到<code>call()</code>的返回值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException &#123;<br>    FutureTask&lt;String&gt; futureTask = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>&lt;String&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread3</span>());<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">thread3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(futureTask);<br>    thread3.start();<br>    <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> futureTask.get();<br>    System.out.println(s);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-线程池"><a href="#4-线程池" class="headerlink" title="4.线程池"></a>4.线程池</h4><h5 id="线程池的工作流程："><a href="#线程池的工作流程：" class="headerlink" title="线程池的工作流程："></a>线程池的工作流程：</h5><p>​当新的任务来到线程池</p><ol><li>如果此时<strong>线程池中线程数少于<code>corePoolSize</code><strong>，就会创建</strong>新的核心线程执行该任务</strong>，<strong>即使有空闲的核心线程</strong></li><li>如果此时<strong>线程池中线程数等于<code>corePoolSize</code><strong>，并且</strong>没有空闲核心线程</strong>，新的任务就会<strong>加入任务队列等待</strong>（如果有空闲核心线程就会让空闲核心线程执行吗？）</li><li>如果<strong>任务队列已满</strong>，但是线程数还<strong>没有达到<code>maximumPoolSize</code><strong>，就会创建</strong>新的临时线程来执行该任务</strong></li><li>如果<strong>线程数量已达最大线程数</strong>，并且<strong>任务队列已满</strong>，新的任务就<strong>会被拒</strong>绝，并由<code>RejectedExecutionHandler</code>处理</li></ol><p>​一个任务被执行完成后，就会从任务队列中拉取下一个任务来执行，核心线程会永久存活，临时线程空闲超过存活时间就会被释放。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException &#123;<br>    <span class="hljs-type">ThreadPoolExecutor</span> <span class="hljs-variable">threadPoolExecutor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<br>    <span class="hljs-number">100</span>, <span class="hljs-comment">//corePoolSize</span><br>    <span class="hljs-number">200</span>, <span class="hljs-comment">//maximumPoolSize</span><br>    <span class="hljs-number">60</span>, <span class="hljs-comment">//keepAliveTime</span><br>    TimeUnit.SECONDS,<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingDeque</span>&lt;&gt;(<span class="hljs-number">100</span>)<br>    );<br>    threadPoolExecutor.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(Thread.currentThread().getName());<br>        &#125;<br>    &#125;);<br>    Future&lt;String&gt; submit = threadPoolExecutor.submit(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Callable</span>&lt;String&gt;() &#123;<br>    <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> String <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.println(Thread.currentThread().getName());<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;HelloWorld&quot;</span>;<br>            &#125;<br>    &#125;);<br>    <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> submit.get();<br>    System.out.println(s);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Javase</category>
      
      <category>多线程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Test Article</title>
    <link href="/2023/04/12/Test-Article/"/>
    <url>/2023/04/12/Test-Article/</url>
    
    <content type="html"><![CDATA[<p>This a test article in order to check the pages</p><span id="more"></span><p><img src="https://gitee.com/wdtte/images/raw/master/202304122310891.png" alt="image-20230412231023834"></p><h3 id="Hello-Test"><a href="#Hello-Test" class="headerlink" title="Hello Test"></a>Hello Test</h3><p>This is a code block</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">package</span> com.wdte.springboot_mybatis.bean;<br><br><span class="hljs-keyword">import</span> lombok.AllArgsConstructor;<br><span class="hljs-keyword">import</span> lombok.Data;<br><span class="hljs-keyword">import</span> lombok.NoArgsConstructor;<br><span class="hljs-keyword">import</span> lombok.ToString;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Wdttee</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span> This is description of class</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@datetime</span> 19:38 2023/4/11 2023</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@NoArgsConstructor</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-meta">@ToString</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-keyword">private</span> Integer id;<br>    <span class="hljs-keyword">private</span> String username;<br>    <span class="hljs-keyword">private</span> String password;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="Fundamentals"><a href="#Fundamentals" class="headerlink" title="Fundamentals"></a>Fundamentals</h1><p>This is the first article in a series of articles about three.js. <a href="https://threejs.org/">Three.js</a> is a 3D library that tries to make it as easy as possible to get 3D content on a webpage.</p><p>Three.js is often confused with WebGL since more often than not, but not always, three.js uses WebGL to draw 3D. <a href="https://webglfundamentals.org/">WebGL is a very low-level system that only draws points, lines, and triangles</a>. To do anything useful with WebGL generally requires quite a bit of code and that is where three.js comes in. It handles stuff like scenes, lights, shadows, materials, textures, 3d math, all things that you’d have to write yourself if you were to use WebGL directly.</p><p>These tutorials assume you already know JavaScript and, for the most part they will use ES6 style. <a href="https://threejs.org/manual/en/prerequisites.html">See here for a terse list of things you’re expected to already know</a>. Most browsers that support three.js are auto-updated so most users should be able to run this code. If you’d like to make this code run on really old browsers look into a transpiler like <a href="https://babeljs.io/">Babel</a>. Of course users running really old browsers probably have machines that can’t run three.js.</p><p>When learning most programming languages the first thing people do is make the computer print <code>&quot;Hello World!&quot;</code>. For 3D one of the most common first things to do is to make a 3D cube. So let’s start with “Hello Cube!”</p><p>Before we get started let’s try to give you an idea of the structure of a three.js app. A three.js app requires you to create a bunch of objects and connect them together. Here’s a diagram that represents a small three.js app</p><p><img src="https://raw.githubusercontent.com/wdtte/image/main/202304120827809.png"></p><p>Things to notice about the diagram above.</p><ul><li><p>There is a <a href="https://threejs.org/docs/#api/en/constants/Renderer"><code>Renderer</code></a>. This is arguably the main object of three.js. You pass a <a href="https://threejs.org/docs/#api/en/scenes/Scene"><code>Scene</code></a> and a <a href="https://threejs.org/docs/#api/en/cameras/Camera"><code>Camera</code></a> to a <a href="https://threejs.org/docs/#api/en/constants/Renderer"><code>Renderer</code></a> and it renders (draws) the portion of the 3D scene that is inside the <em>frustum</em> of the camera as a 2D image to a canvas.</p></li><li><p>There is a <a href="https://threejs.org/manual/en/scenegraph.html">scenegraph</a> which is a tree like structure, consisting of various objects like a <a href="https://threejs.org/docs/#api/en/scenes/Scene"><code>Scene</code></a> object, multiple <a href="https://threejs.org/docs/#api/en/objects/Mesh"><code>Mesh</code></a> objects, <a href="https://threejs.org/docs/#api/en/lights/Light"><code>Light</code></a> objects, <a href="https://threejs.org/docs/#api/en/objects/Group"><code>Group</code></a>, <a href="https://threejs.org/docs/#api/en/core/Object3D"><code>Object3D</code></a>, and <a href="https://threejs.org/docs/#api/en/cameras/Camera"><code>Camera</code></a> objects. A <a href="https://threejs.org/docs/#api/en/scenes/Scene"><code>Scene</code></a> object defines the root of the scenegraph and contains properties like the background color and fog. These objects define a hierarchical parent&#x2F;child tree like structure and represent where objects appear and how they are oriented. Children are positioned and oriented relative to their parent. For example the wheels on a car might be children of the car so that moving and orienting the car’s object automatically moves the wheels. You can read more about this in <a href="https://threejs.org/manual/en/scenegraph.html">the article on scenegraphs</a>.</p><p>Note in the diagram <a href="https://threejs.org/docs/#api/en/cameras/Camera"><code>Camera</code></a> is half in half out of the scenegraph. This is to represent that in three.js, unlike the other objects, a <a href="https://threejs.org/docs/#api/en/cameras/Camera"><code>Camera</code></a> does not have to be in the scenegraph to function. Just like other objects, a <a href="https://threejs.org/docs/#api/en/cameras/Camera"><code>Camera</code></a>, as a child of some other object, will move and orient relative to its parent object. There is an example of putting multiple <a href="https://threejs.org/docs/#api/en/cameras/Camera"><code>Camera</code></a> objects in a scenegraph at the end of <a href="https://threejs.org/manual/en/scenegraph.html">the article on scenegraphs</a>.</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>test</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IO流</title>
    <link href="/2023/01/02/IO%E6%B5%81/"/>
    <url>/2023/01/02/IO%E6%B5%81/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h1 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h1><p>FileFilter，类似于外部比较器</p><p>输入、输出、流（这是载体）</p><p>GC不会自动回收的东西：</p><ul><li>网络（如Socket）</li><li>IO</li><li>数据库</li></ul><p><strong>为什么要关流？</strong></p><p>因为JVM的垃圾回收机制不会自动回收：IO、网络、数据库等资源。</p><h2 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h2><p>xxxReader&#x2F;Writer</p><img src="https://raw.githubusercontent.com/wdtte/image/main/202308311444606.png" alt="image-20230831144400464" style="zoom:50%;" /><p>read()只读一个字符，返回unicode码，读不到是-1</p><img src="https://raw.githubusercontent.com/wdtte/image/main/202308311619371.png" alt="image-20230831161627171" style="zoom:50%;" /><p>读多个字符，返回读到的数量，读不到了是-1</p><p>如果剩余字符数小于数组长度，只会覆盖前几个元素然后直接拼接（原文是abcde）</p><p><strong>解决方案</strong>：用（chars,0,count）拼接</p><p>try-with-resource的try里面只能是实现自Autocloseable的实例化</p><h2 id="字节流-1"><a href="#字节流-1" class="headerlink" title="字节流"></a>字节流</h2><p>XXXInputStream&#x2F;OutputStream</p><img src="https://raw.githubusercontent.com/wdtte/image/main/202308311656042.png" alt="image-20230831165635953" style="zoom:50%;" /><img src="https://raw.githubusercontent.com/wdtte/image/main/202308311656035.png" alt="image-20230831165606964" style="zoom:50%;" /><p>读一个字节，返回byte值（范围0~255）</p><p>读到的数量，读不到就是-1</p><h2 id="缓冲流"><a href="#缓冲流" class="headerlink" title="缓冲流"></a>缓冲流</h2><ul><li>BufferedReader</li><li>BufferedWriter</li><li>BufferedFileInputStream</li><li>BufferedFileOutputStream</li></ul><h2 id="转换流（字节–-gt-字符）"><a href="#转换流（字节–-gt-字符）" class="headerlink" title="转换流（字节–&gt;字符）"></a>转换流（字节–&gt;字符）</h2><p>字符流本质上也是一种字节流，可以相互转换，但是涉及到编码</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs Java"><span class="hljs-type">BufferedReader</span> <span class="hljs-variable">bf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(<span class="hljs-string">&quot;&quot;</span>),<span class="hljs-string">&quot;UTF8&quot;</span>);<br></code></pre></td></tr></table></figure><h2 id="流的分类"><a href="#流的分类" class="headerlink" title="流的分类"></a>流的分类</h2><p>按照处理数据单位划分 </p><p>• 字符流：用于处理文本数据 </p><p>• 字节流：用于处理二进制数据</p><p> 按照方向不同划分</p><p> • 输入流：用于处理程序外部的数据输送到程序内部的操作</p><p> • 输出流：用于处理程序内部的数据输送到程序外部的操作</p><p>按照处理机制不同划分 </p><p>• 节点流：程序直接和数据目标之间建立管道</p><p>• 处理流：处理流本身有很多种，是在节点流的基础上为了优化不同方面的特性而打造的一种扩展</p><img src="https://raw.githubusercontent.com/wdtte/image/main/202308311916580.png" alt="image-20230831191653385" style="zoom:80%;" /><h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><p>将对象持久化到文件</p><p>序列化ID可以不用加，加了就会比对</p><p>transient序列化排除</p><p>集合ArrayList和LinkedList这种是序列化的里面的对象，不是序列化整个集合，为了节约空间</p><p>readObject，writeObject</p><h2 id="Introduction-to-NIO"><a href="#Introduction-to-NIO" class="headerlink" title="Introduction to NIO"></a>Introduction to NIO</h2><p><strong>阻塞与非阻塞</strong></p><p>阻塞与非阻塞是描述进程在访问某个资源时，数据是否准备就绪的的一种处理方式。当数据没有准备就绪时：</p><ul><li>阻塞：线程持续等待资源中数据准备完成，直到返回响应结果。</li><li>非阻塞：线程直接返回结果，不会持续等待资源准备数据结束后才响应结果。</li></ul><p><strong>同步与异步</strong></p><ul><li>同步与异步是指访问数据的机制，同步一般指主动请求并等待IO操作完成的方式。</li><li>异步则指主动请求数据后便可以继续处理其它任务，随后等待IO操作完毕的通知。</li></ul><p>烧开水： </p><ul><li>普通水壶煮水，站在旁边，主动的看水开了没有？同步的阻塞</li><li>普通水壶煮水，去干点别的事，每过一段时间去看看水开了没有，水没开就走人。同步非阻塞 </li><li>响水壶煮水，站在旁边，不会每过一段时间主动看水开了没有。如果水开了，水壶自动通知他。异步阻塞</li><li>响水壶煮水，去干点别的事，如果水开了，水壶自动通知他。异步非阻塞</li></ul><p><strong>模型：</strong></p><ul><li><p><strong>传统BIO模型</strong></p><p>传统BIO是一种同步的阻塞IO，IO在进行读写时，该线程将被阻塞，线程无法进行其它操作。 IO流在读取时，会阻塞。直到发生以下情况：</p><ul><li><p>有数据可以读取</p></li><li><p>数据读取完成。</p></li><li><p>发生异常</p></li></ul></li><li><p><strong>伪异步IO模型</strong></p><p>以传统BIO模型为基础，通过线程池的方式维护所有的IO线程，实现相对高效的线程开销及管理。</p></li><li><p><strong>NIO模型</strong></p><p>…</p></li></ul><p><a href="https://cloud.tencent.com/developer/article/1839636">参考资料</a></p><h2 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h2><ul><li><p><strong>非阻塞</strong>（同步非阻塞）</p><p>在读写数据的时候不会阻塞程序，同时处理别的事</p></li><li><p><strong>多路复用</strong></p><ul><li>一个线程处理多个通道（Channel），通过选择器（Selector）和事件触发机制来切换通道。—&gt;可以做到一个线程同时处理多个客户端连接</li><li>通道是双向的，可读又可写，传统IO要获取输入流、输出流才行</li></ul></li><li><p><strong>面向缓冲区</strong>（Buffer）</p><p>传统IO是面向流的，面向缓冲区的读写速度更高，与传统IO的缓冲流相似但是比缓冲流更灵活。</p><p>NIO中的缓冲区可以被重复使用，减少了内存分配和垃圾回收的开销。</p></li></ul><p><strong>使用NIO进行文件拷贝的两种方式</strong></p><p>FileChannel.open(Path,StandardOpenOption.XXX).read(ByteBuffer.allocate(int))</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-type">Path</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> Paths.get(<span class="hljs-string">&quot;C:\\Users\\YanXin\\Desktop\\简历投递.txt&quot;</span>);<br><span class="hljs-type">Path</span> <span class="hljs-variable">path1</span> <span class="hljs-operator">=</span> Paths.get(<span class="hljs-string">&quot;C:\\Users\\YanXin\\Desktop\\简历投递_copy.txt&quot;</span>);<br><span class="hljs-keyword">try</span> (<span class="hljs-type">FileChannel</span> <span class="hljs-variable">fileChannel</span> <span class="hljs-operator">=</span> FileChannel.open(path);<br>     <span class="hljs-type">FileChannel</span> <span class="hljs-variable">fileChannel1</span> <span class="hljs-operator">=</span> FileChannel.open(path1, StandardOpenOption.WRITE, StandardOpenOption.CREATE_NEW, StandardOpenOption.APPEND)) &#123;<br>    <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">byteBuffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">5</span>);<br><span class="hljs-type">int</span> count;<br><span class="hljs-keyword">while</span> ((count = fileChannel.read(byteBuffer)) != -<span class="hljs-number">1</span>) &#123;<br>        byteBuffer.flip();<br>        fileChannel1.write(byteBuffer);<br>        byteBuffer.clear();<br>    &#125;<br>&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>&#125;<br></code></pre></td></tr></table></figure><p>FileReader.getChannel().read(CharBuffer.allocate(int))</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">try</span> (<span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fileInputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;D:\\IdeaProjects\\Review_JavaSe\\Module13_IOStream\\src\\result.txt&quot;</span>);<br>     <span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">fileOutputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;D:\\IdeaProjects\\Review_JavaSe\\Module13_IOStream\\src\\result_out2.txt&quot;</span>);<br>     <span class="hljs-type">FileReader</span> <span class="hljs-variable">fileReader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(<span class="hljs-string">&quot;D:\\IdeaProjects\\Review_JavaSe\\Module13_IOStream\\src\\result.txt&quot;</span>);<br>     <span class="hljs-type">FileChannel</span> <span class="hljs-variable">sourceChannel</span> <span class="hljs-operator">=</span> fileInputStream.getChannel();<br>     <span class="hljs-type">FileChannel</span> <span class="hljs-variable">targetChannel</span> <span class="hljs-operator">=</span> fileOutputStream.getChannel()) &#123;<br><br>            <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">byteBuffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">5</span>);<br>            <span class="hljs-type">CharBuffer</span> <span class="hljs-variable">charBuffer</span> <span class="hljs-operator">=</span> CharBuffer.allocate(<span class="hljs-number">3</span>);<br><br>            <span class="hljs-keyword">while</span> (fileReader.read(charBuffer) != -<span class="hljs-number">1</span>) &#123;<br>                charBuffer.flip(); <span class="hljs-comment">//设置position和limit，position表示缓冲区从哪个位置开始读写，limit表示缓冲区读写的上限</span><br>                System.out.print(charBuffer);<br>                charBuffer.clear();<br>            &#125;<br>            <span class="hljs-keyword">while</span> (sourceChannel.read(byteBuffer) != -<span class="hljs-number">1</span>) &#123;<br>                byteBuffer.flip(); <span class="hljs-comment">//因为下面这行中的.array()会返回底层数组，不涉及缓冲区的position和limit，所以去掉flip没有影响</span><br>                System.out.print(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(byteBuffer.array(), StandardCharsets.UTF_8));<br>                targetChannel.write(byteBuffer);<br>                byteBuffer.clear();<br>            &#125;<br><br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125;<br></code></pre></td></tr></table></figure><h3 id="“BIO”-“AIO”-“NIO”"><a href="#“BIO”-“AIO”-“NIO”" class="headerlink" title="“BIO”, “AIO”, “NIO”"></a>“BIO”, “AIO”, “NIO”</h3><p>BIO：Blocking Input&#x2F;Output，阻塞式IO</p><p>AIO：Asynchronous Input&#x2F;Output，异步非阻塞IO，也在NIO库中（java.nio.*）</p><p>NIO：New Input&#x2F;Output，No Blocking Input&#x2F;Output</p><p><img src="https://raw.githubusercontent.com/wdtte/image/main/202309021207817.png" alt="506b02241365e7b7c1ae2019f70679f"></p><p>文件拷贝</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo_FileCopy_Reader</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">BufferedReader</span> <span class="hljs-variable">bufferedReader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(<span class="hljs-string">&quot;C:\\Users\\YanXin\\Desktop\\简历投递.txt&quot;</span>));<br>             <span class="hljs-type">BufferedWriter</span> <span class="hljs-variable">bufferedWriter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedWriter</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(<span class="hljs-string">&quot;C:\\Users\\YanXin\\Desktop\\简历投递_copy.txt&quot;</span>))) &#123;<br>            String s;<br>            <span class="hljs-keyword">while</span> ((s = bufferedReader.readLine()) != <span class="hljs-literal">null</span>) &#123;<br>                bufferedWriter.write(s);<br>                bufferedWriter.newLine();<br>                bufferedWriter.flush();<br>            &#125;<br>            System.out.println(<span class="hljs-string">&quot;拷贝完成！&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo_FileCopy_InputStream</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fileInputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;C:\\Users\\YanXin\\Desktop\\简历投递.txt&quot;</span>);<br>             <span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">fileOutputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;C:\\Users\\YanXin\\Desktop\\简历投递_copy.txt&quot;</span>, <span class="hljs-literal">true</span>)) &#123;<br>            <span class="hljs-type">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">6</span>];<br>            <span class="hljs-type">int</span> count;<br>            <span class="hljs-keyword">while</span> ((count = fileInputStream.read(bytes)) != -<span class="hljs-number">1</span>) &#123;<br>                fileOutputStream.write(bytes, <span class="hljs-number">0</span>, count);<br>            &#125;<br>            System.out.println(<span class="hljs-string">&quot;拷贝完成！&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Javase</category>
      
      <category>IO流</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IO流</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/03/01/hello-world/"/>
    <url>/2022/03/01/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Hello-Hexo"><a href="#Hello-Hexo" class="headerlink" title="Hello Hexo"></a>Hello Hexo</h2><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
