<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>注解&amp;反射</title>
    <link href="/2023/08/26/%E6%B3%A8%E8%A7%A3&amp;%E5%8F%8D%E5%B0%84/"/>
    <url>/2023/08/26/%E6%B3%A8%E8%A7%A3&amp;%E5%8F%8D%E5%B0%84/</url>
    
    <content type="html"><![CDATA[<h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><h3 id="注解和注释"><a href="#注解和注释" class="headerlink" title="注解和注释"></a>注解和注释</h3><p>注释不影响代码 &amp; 注解有一些特定的功能</p><h3 id="预定义注解"><a href="#预定义注解" class="headerlink" title="预定义注解"></a>预定义注解</h3><p><strong><code>@Override</code></strong> <strong><code>@Deprated</code></strong> <strong><code>SuppressWarnings</code></strong></p><h4 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h4><p>用于定义注解的注解</p><p><strong><code>@Target</code></strong>  注解位置</p><p><strong><code>@RetentionPolicy</code></strong> 保留周期</p><p>…</p><h3 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h3><ul><li>用元注解创建自定义注解</li><li>作用：存储一个值 XXX.class.getAnnotation().xx();拿到抽象方法返回值，就是这里存储的值。<ul><li>@XXX(a&#x3D;””,b&#x3D;””)</li><li>如果恰好有一个抽象方法名字是value，注解调用的时候就不用写名字</li></ul></li></ul><h3 id="自定义注解和预定义注解的区别"><a href="#自定义注解和预定义注解的区别" class="headerlink" title="自定义注解和预定义注解的区别"></a>自定义注解和预定义注解的区别</h3><p>自定义注解不像预定义注解有一些默认的功能，自定义注解要配合反射使用，往往是在代码中直接定义一些值，这些值将在实际程序运行的时候加载和使用。</p><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><h3 id="什么是反射"><a href="#什么是反射" class="headerlink" title="什么是反射"></a>什么是反射</h3><p>反射是用代码操作代码、用面向对象诠释面向对象的一种机制&#x2F;技术。</p><p>面向对象中，所有的对象都有对应的类（除了int、char、byte…）。现在把所有的类都看作对象，那么就有描述类的类，这个类就是<code>java.lang.Class</code></p><h4 id="如何获取Class的对象"><a href="#如何获取Class的对象" class="headerlink" title="如何获取Class的对象"></a>如何获取Class的对象</h4><ul><li>类.class</li><li>对象(指通俗的对象).getClass()</li><li>Class.$forName$(“全限定类名”)</li></ul><h4 id="为什么synchronized锁旗标用当前类-class？"><a href="#为什么synchronized锁旗标用当前类-class？" class="headerlink" title="为什么synchronized锁旗标用当前类.class？"></a>为什么synchronized锁旗标用当前类.class？</h4><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassDemo2</span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * ClassDemo2.class</span><br><span class="hljs-comment">     */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">a</span><span class="hljs-params">()</span>&#123;<br>        <br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">b</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">synchronized</span>(ClassDemo2.class)&#123;<br>            <br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><img src="https://raw.githubusercontent.com/wdtte/image/main/202308260912055.png" alt="image-20230826091251008" style="zoom:50%;" /><p>把ClassDemo2看作对象，描述它的类是Class，Class的一个对象引用的地址就是这个“对象”的地址，这个“对象”只存在一个，地址只存在一个，所以不管什么时候在哪里以哪种方式获取到的都是同一个字节码对象。</p><h3 id="反射-1"><a href="#反射-1" class="headerlink" title="反射"></a>反射</h3><ul><li>获取内容<ul><li>构造方法</li><li>方法</li><li>字段</li></ul></li><li>创建对象</li><li>执行方法</li></ul><h3 id="暴力反射"><a href="#暴力反射" class="headerlink" title="暴力反射"></a>暴力反射</h3><p>getDeclaredXXX()获取到访问不到的内容（比如private修饰的构造方法、字段、方法）</p><p>但现在拿到了却没有权限使用，设置一下权限 setAccessable(true) </p><p>然后newInstance()、set()、invoke()等</p><h3 id="执行字节码文件里面的方法"><a href="#执行字节码文件里面的方法" class="headerlink" title="执行字节码文件里面的方法"></a>执行字节码文件里面的方法</h3><p>如果只拿到字节码文件，往往没有办法直接运行，用反射可以</p><p>Class.$classforName$(“字节码文件对应的全限定类名”).getXXX().invoke()等</p>]]></content>
    
    
    <categories>
      
      <category>Javase</category>
      
    </categories>
    
    
    <tags>
      
      <tag>注解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring</title>
    <link href="/2023/08/25/Spring/"/>
    <url>/2023/08/25/Spring/</url>
    
    <content type="html"><![CDATA[<p>Introduction to Spring Framework </p><span id="more"></span><h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><h3 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h3><p>Inversion Of Control，一种编程模式，将<strong>依赖关系的获取和管理转移到了容器或框架中</strong>，从而实现了组件的松耦合。</p><h3 id="ApplicationContext"><a href="#ApplicationContext" class="headerlink" title="ApplicationContext"></a>ApplicationContext</h3><p>就是管理bean的容器，ioc容器。</p><h4 id="构建context-amp-bean的方式"><a href="#构建context-amp-bean的方式" class="headerlink" title="构建context&amp;bean的方式"></a>构建context&amp;bean的方式</h4><p>两种方式：</p><ul><li><p>xml创建bean</p><figure class="highlight xml"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> +<span class="hljs-attr">一堆命名空间</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContex</span>(<span class="hljs-string">&quot;这里面放resources目录下的配置文件路径&quot;</span>).<span class="hljs-keyword">var</span><br><span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> context.get(<span class="hljs-string">&quot;beanId&quot;</span>); <span class="hljs-comment">//&lt;T&gt; t = context.getBean(&quot;beanId&quot;,T.class);</span><br><span class="hljs-comment">//这里的实际类型就是bean的实际类型，只是用Object来接收它，所以直接打印调用的是重写的tostring</span><br><span class="hljs-comment">//默认tostring返回 getClass().getName() + &quot;@&quot; + Integer.toHexString(hashCode())，而且默认的hashCode是本地方法，根据对象的实际内存地址得到哈希码（与内容无关），如果没有哈希冲突，这个哈希码可以唯一标识对象。重写的hashCode大多都是根据内容得到哈希码，内容一样的两个对象得到一样的哈希码，比如两个值相同的字符串。</span><br></code></pre></td></tr></table></figure></li><li><p>配置类创建bean（注解）</p><p><code>@ComponentScan(&quot;&quot;)</code></p><p><code>@Configuration</code> <code>@Bean</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">new</span> <span class="hljs-title class_">AnnotationConfigApplicationContext</span>(T.class).<span class="hljs-keyword">var</span><br></code></pre></td></tr></table></figure></li><li><p>@component</p><p>修饰在类上，context在初始化的时候就会实例化一个该类的对象放入context</p></li><li><p>两种可以混合使用</p><ul><li>在xml中<code>&lt;context:component-scan base-package=&quot;&quot;&gt;</code>或者<code>@ComponentScan(&quot;&quot;)</code>；然后注解创建</li><li>在配置类上<code>@ImportResource(&quot;/.../XXX.xml&quot;)</code>导入配置文件；</li></ul></li><li><p>集合的创建</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">util:list</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;list&quot;</span> <span class="hljs-attr">value-type</span>=<span class="hljs-string">&quot;java.lang.String&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>El1<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>El2<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>El3<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">util:list</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">util:set</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;set&quot;</span> <span class="hljs-attr">value-type</span>=<span class="hljs-string">&quot;com.wdte.bean.User&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>wdte<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>liys<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>publishBy<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">util:set</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">util:map</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;map&quot;</span> <span class="hljs-attr">key-type</span>=<span class="hljs-string">&quot;java.lang.String&quot;</span> <span class="hljs-attr">value-type</span>=<span class="hljs-string">&quot;com.wdte.bean.Note&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;note-1&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;note1&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">util:map</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这里还需要注册类型转换器把id转成实际的bean</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs xml">import org.springframework.core.convert.converter.Converter;<br><br>public class StringToUserConverter implements Converter&lt;String, User&gt; &#123;<br>    @Override<br>    public User convert(String source) &#123;<br>        // 在这里执行将字符串转换为User对象的逻辑<br>        // 例如，根据字符串查询数据库获取User对象<br>        // 然后返回User对象<br>    &#125;<br>&#125;<br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;conversionService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.context.support.ConversionServiceFactoryBean&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;converters&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">set</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.example.StringToUserConverter&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">set</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="DI"><a href="#DI" class="headerlink" title="DI"></a>DI</h3><p>Dependency Injection，一种特殊的赋值，通过外部的方式将一个对象的依赖关系注入到该对象中，而不是由该对象自己去创建或获取依赖对象。（解耦）</p><ul><li>构造方法注入 <code>&lt;constructor-arg name=&quot;&quot; value=&quot;&quot;/&gt;</code></li><li>setter方法注入（通过外部文件如yaml就是这种方式） <code>&lt;property name=&quot;&quot; value=&quot;&quot;/&gt;</code></li><li>注解注入 <code>@Component</code>，需要开启包扫描<code>@ComponentScan()</code> ||  <code>&lt;context:component-scan base-package=&quot;&quot;&gt;</code></li><li><ul><li>构造方法和setter方法可以混用，因为默认空参构造</li><li>前两种方法的赋值如果传入的不是基本类型，value变ref，引用context中已有的bean</li><li>使用工厂模式的工厂方法创建的bean首先要创建工厂实例，然后用<code>factory-bean=“”</code>传入工厂实例和<code>factory-mothod</code>指定工厂方法，然后嵌套<code>&lt;constructor-arg/&gt;</code>传构造方法参数</li></ul></li></ul><p>bean标签是创建bean，里面嵌套的赋值是DI；自动装配是为了更灵活地DI</p><p>特殊的有集合bean的创建和DI，还需要引入命名空间</p><h3 id="AutoWiring"><a href="#AutoWiring" class="headerlink" title="AutoWiring"></a>AutoWiring</h3><p>在Spring框架中，自动装配（Autowiring）是一种通过Spring容器自动将组件之间的依赖关系建立起来的机制。通过自动装配，您可以告诉Spring框架，哪些组件需要依赖哪些其他组件，而Spring会在运行时自动将这些依赖关系满足。</p><p>自动装配可以通过注解或XML配置来实现，最常用的方式是使用注解。</p><p>要是没有自动装配，需要用户对每个bean的字段一个一个手动赋值，复杂类型的用ref属性引用已经存在的bean</p><p>有了自动装配，就不用手动赋值了。配置文件的所有自动装配都不能装配简单类型(包括String、Integer…)</p><p><strong>自动装配的类型</strong>：</p><ul><li><p><strong>byName：</strong>在context里面找到<code>beanId</code>和字段名一样的bean并赋值</p><p>​需要保证<code>beanId</code>唯一性，并且如果有多个类型不一样的bean使用同一个id会类型转换错误</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs xml">    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;publishBy&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.wdte.bean.User&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;publish User&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;age&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;18&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;content&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;java.lang.String&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Hello World&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;note1&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.wdte.bean.Note&quot;</span> <span class="hljs-attr">autowire</span>=<span class="hljs-string">&quot;byName&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;1&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br>@Data<br>@NoArgsConstructor<br>@AllArgsConstructor<br>public class Note &#123;<br>    private Integer id;<br>    private String content;<br>    private User publishBy;<br>&#125;<br>@Data<br>@NoArgsConstructor<br>@AllArgsConstructor<br>public class User &#123;<br>    private String name;<br>    private int age;<br>&#125;<br><br>这里content不会被自动装配<br></code></pre></td></tr></table></figure></li><li><p><strong>byType：</strong>在context里面找到该类型的唯一一个实例并赋值</p><p>要么有一个该类型实例要么没有，没有或者有多个会报错</p></li><li><p><strong>构造方法（constructor）</strong></p><ol><li><p>首先byType再byName</p></li><li><p>使用了autowire&#x3D;”constructor”属性，实例化这个对象的时候就会 根据需要的 DI 在提供的构造方法中<strong>选择合适的构造方法</strong>实例化</p></li><li><p>如果 被选中的构造方法中包含一个找不到的形参（此时context中没有该类型的bean||有多个该类型的bean）就会报错</p></li><li><p>没有被构造方法参数列表包含的字段会被设为字段类型的默认值</p></li></ol></li><li><p><strong>自定义自动装配（custom）</strong>：通过实现<code>BeanFactoryPostProcessor</code>接口，可以自定义自动装配逻辑。</p></li><li><p><strong>无自动装配</strong></p></li></ul><p>对象在实例化的时候就会传参引入依赖，这种做法更保险，但是还是要根据实际需求选择自动装配的方式。</p><p>自动装配简化了Spring应用程序的配置，提高了代码的可维护性和可读性。然而，在使用自动装配时，需要谨慎处理好依赖关系，避免出现不清晰的情况，以确保应用程序的正确性。</p><p><strong>bean在 DI 和 自动装配时的先后顺序</strong></p><p> <code>场景</code> 如果A类中需要 DI 一个B类类型的字段 结果 A在进行DI时 B还没有注入到IOC容器</p><p><code>解决方案</code> Spring 在设计之初考虑到这个问题 会尽可能的分析依赖关系 先从最下层的依赖bean创建并放入IOC容器 然后逐级向上创建对象并进行DI 然而 这并不稳妥 Spring只是尽可能做到这个事情 </p><p>Spring团队也考虑到这个问题 在bean标签上提供了 depends-on 属性 方便我们声明依赖关系 Spring 得到这个依赖关系的树状图后 会先从最底层的bean开始创建并进行DI</p><h4 id="DI-amp-Autowring方式对比"><a href="#DI-amp-Autowring方式对比" class="headerlink" title="DI&amp;Autowring方式对比"></a>DI&amp;Autowring方式对比</h4><table><thead><tr><th>配置类 @Configuration</th><th>@Component</th></tr></thead><tbody><tr><td>将一个对象注入到IOC容器</td><td>将一个对象注入到IOC容器</td></tr><tr><td>@Bean注解注在方法上</td><td>@Component注解在类上 当前类的一个实例会被放入IOC</td></tr><tr><td>自己new 或者 new完set</td><td>@Value + @Autowired + @Resource</td></tr><tr><td>调用被@Bean注解修饰的方法</td><td>@Autowired + @Resource 自动装配</td></tr><tr><td>往往在注入其他人或者开源团队写好的代码中的对象到IOC容器中</td><td>往往是注入自己的一个类的对象到IOC容器中</td></tr></tbody></table><p>@Resource是JavaEE规范提供的，不是spring的注解，在别的框架也可以用。</p><p>@Resource主要是byName的装配，更适合字段装配；@Autowred主要是byType的装配，不太适合但是可以用在字段上。</p><h4 id="Value"><a href="#Value" class="headerlink" title="@Value"></a>@Value</h4><p><code>@Value</code> 是 Spring 框架中的一个注解，用于将值注入到 Spring 管理的 bean 中的属性中。这允许你在配置文件中指定值，然后在代码中使用这些值，从而实现了配置和代码的分离。<code>@Value</code> 注解可以用于字段、方法、构造函数参数和方法参数上。</p><p>在注入值时，<code>@Value</code> 可以用于以下不同的场景：</p><ol><li><p><strong>注入简单值：</strong> 你可以使用 <code>@Value</code> 注解将一个简单的值（如字符串、数字等）注入到属性中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Value(&quot;Hello, Spring!&quot;)</span><br><span class="hljs-keyword">private</span> String greeting;<br></code></pre></td></tr></table></figure></li><li><p><strong>注入属性值：</strong> 你可以使用 <code>@Value</code> 注解来注入其他 bean 的属性值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Value(&quot;#&#123;otherBean.property&#125;&quot;)</span><br><span class="hljs-keyword">private</span> String someProperty;<br></code></pre></td></tr></table></figure></li><li><p><strong>注入外部配置：</strong> <code>@Value</code> 可以用来注入外部配置文件（如 properties 文件）中的属性值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Value(&quot;$&#123;app.url&#125;&quot;)</span><br><span class="hljs-keyword">private</span> String appUrl;<br></code></pre></td></tr></table></figure></li><li><p><strong>SpEL 表达式：</strong> 你还可以使用 Spring 表达式语言（SpEL）来计算属性值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">‘xxxxxxxxxx2 <span class="hljs-number">1</span><span class="hljs-meta">@Value(&quot;#&#123; T(java.lang.Math).PI * 2 * radius &#125;&quot;)</span>2private <span class="hljs-type">double</span> circumference;java<br></code></pre></td></tr></table></figure></li></ol><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><h3 id="懒加载"><a href="#懒加载" class="headerlink" title="懒加载"></a>懒加载</h3><h3 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h3><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><h3 id="循环依赖"><a href="#循环依赖" class="headerlink" title="循环依赖"></a>循环依赖</h3><p>循环依赖（Circular Dependency）是指两个或多个类之间存在相互依赖关系的情况，从而形成了一个闭环。这种情况下，每个类都依赖于另一个类，导致无法在不出现问题的情况下正确地创建这些类的实例。循环依赖可能会导致程序运行时的错误、死锁、性能问题以及代码难以理解和维护。</p><p>在软件开发中，循环依赖是应该避免的，因为它们可能会引发一系列问题。下面是一些关于循环依赖的问题和解决方法：</p><p><strong>问题：</strong></p><ol><li><p><strong>无法正确实例化：</strong> 当两个或多个类互相依赖时，创建它们的实例可能会导致死循环或栈溢出，从而无法成功初始化这些类。</p></li><li><p><strong>不稳定性：</strong> 循环依赖可能导致对象的状态不稳定。因为循环依赖可能会导致对象的构造和初始化过程交织在一起，使得对象的状态在不同步骤中发生变化。</p></li><li><p><strong>难以理解和维护：</strong> 循环依赖会增加代码的复杂性，使代码难以理解和维护。代码中出现循环依赖会使得类之间的关系变得混乱，增加了调试和修改的困难。</p></li></ol><p><strong>解决方法：</strong></p><ol><li><p><strong>设计调整：</strong> 重新考虑类之间的依赖关系，看是否可以进行逻辑上的调整，以减少循环依赖。</p></li><li><p><strong>引入中间层：</strong> 可以考虑引入一个中间层或接口来隔离循环依赖，从而将直接依赖转变为间接依赖。</p></li><li><p><strong>使用延迟初始化：</strong> 在 Spring 等容器中，可以使用延迟初始化（Lazy Initialization）来解决循环依赖问题。容器会在需要时才创建对象，从而避免了循环依赖导致的初始化问题。</p></li><li><p><strong>使用构造函数注入：</strong> 在 Spring 中，使用构造函数注入可以降低循环依赖的风险。构造函数注入在对象创建时就完成了依赖的注入，避免了后续初始化过程中的问题。</p></li></ol><p>总的来说，循环依赖是一种应该尽量避免的情况，因为它会引发一系列问题。在设计和编写代码时，需要注意依赖关系，以确保类之间的依赖关系清晰，避免出现循环依赖。</p>]]></content>
    
    
    <categories>
      
      <category>JavaEE</category>
      
      <category>spring</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java创建线程的四种方法</title>
    <link href="/2023/04/13/Java%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%96%B9%E6%B3%95/"/>
    <url>/2023/04/13/Java%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>四种方法包括：实现Runnable接口实现run ()方法、继承Thread类重写run()方法、实现Callable接口实现call()方法、由线程池通过submit() | execute() 方法创建</p><span id="more"></span><h3 id="Java创建线程的四种方法"><a href="#Java创建线程的四种方法" class="headerlink" title="Java创建线程的四种方法"></a>Java创建线程的四种方法</h3><h4 id="1-实现Runnable接口"><a href="#1-实现Runnable接口" class="headerlink" title="1. 实现Runnable接口"></a>1. 实现<code>Runnable</code>接口</h4><p>创建一个类实现<code>Runnable</code>接口，实现<code>run()</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread1</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(Thread.currentThread().getName());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>实例化一个该类的对象传入<code>Thread()</code>构造方法，通过创建的thread对象调用<code>start()</code>方法就开启了该线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">thread1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread1</span>());<br>    thread1.start();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-继承Thread类"><a href="#2-继承Thread类" class="headerlink" title="2. 继承Thread类"></a>2. 继承<code>Thread</code>类</h4><p>创建一个类继承<code>Thread</code>类，重写<code>run()</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(Thread.currentThread().getName());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>实例化一个该类的对象传入<code>Thread()</code>构造方法，通过创建的thread对象调用<code>start()</code>方法就开启了该线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">thread2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread2</span>());<br>    thread2.start();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-实现-Callable接口"><a href="#3-实现-Callable接口" class="headerlink" title="3.实现 Callable接口"></a>3.实现 <code>Callable</code>接口</h4><p>创建一个类实现<code>Callable</code>接口，实现<code>call()</code>方法</p><p><code>call()</code>方法是有返回值的，所以这种方法用来创建有返回值的线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread3</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Callable</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.println(Thread.currentThread().getName());<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello World&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>实例化一个该类的对象传入<code>FutureTask&lt;&gt;()</code>构造方法，创建一个<code>FutureTask&lt;&gt;</code>类型的对象，将该对象传入<code>Thread()</code>构造方法，调用<code>start()</code>方法就开启了该线程（泛型是返回值的类型）</p><p>通过上面创建的<code>FutureTask&lt;&gt;</code>类型的对象调用<code>get()</code>方法可以拿到<code>call()</code>的返回值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException &#123;<br>    FutureTask&lt;String&gt; futureTask = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>&lt;String&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread3</span>());<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">thread3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(futureTask);<br>    thread3.start();<br>    <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> futureTask.get();<br>    System.out.println(s);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-线程池"><a href="#4-线程池" class="headerlink" title="4.线程池"></a>4.线程池</h4><h5 id="线程池的工作流程："><a href="#线程池的工作流程：" class="headerlink" title="线程池的工作流程："></a>线程池的工作流程：</h5><p>​当新的任务来到线程池</p><ol><li>如果此时<strong>线程池中线程数少于<code>corePoolSize</code><strong>，就会创建</strong>新的核心线程执行该任务</strong>，<strong>即使有空闲的核心线程</strong></li><li>如果此时<strong>线程池中线程数等于<code>corePoolSize</code><strong>，并且</strong>没有空闲核心线程</strong>，新的任务就会<strong>加入任务队列等待</strong>（如果有空闲核心线程就会让空闲核心线程执行吗？）</li><li>如果<strong>任务队列已满</strong>，但是线程数还<strong>没有达到<code>maximumPoolSize</code><strong>，就会创建</strong>新的临时线程来执行该任务</strong></li><li>如果<strong>线程数量已达最大线程数</strong>，并且<strong>任务队列已满</strong>，新的任务就<strong>会被拒</strong>绝，并由<code>RejectedExecutionHandler</code>处理</li></ol><p>​一个任务被执行完成后，就会从任务队列中拉取下一个任务来执行，核心线程会永久存活，临时线程空闲超过存活时间就会被释放。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException &#123;<br>    <span class="hljs-type">ThreadPoolExecutor</span> <span class="hljs-variable">threadPoolExecutor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<br>    <span class="hljs-number">100</span>, <span class="hljs-comment">//corePoolSize</span><br>    <span class="hljs-number">200</span>, <span class="hljs-comment">//maximumPoolSize</span><br>    <span class="hljs-number">60</span>, <span class="hljs-comment">//keepAliveTime</span><br>    TimeUnit.SECONDS,<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingDeque</span>&lt;&gt;(<span class="hljs-number">100</span>)<br>    );<br>    threadPoolExecutor.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(Thread.currentThread().getName());<br>        &#125;<br>    &#125;);<br>    Future&lt;String&gt; submit = threadPoolExecutor.submit(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Callable</span>&lt;String&gt;() &#123;<br>    <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> String <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.println(Thread.currentThread().getName());<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;HelloWorld&quot;</span>;<br>            &#125;<br>    &#125;);<br>    <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> submit.get();<br>    System.out.println(s);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Javase</category>
      
      <category>多线程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Test Article</title>
    <link href="/2023/04/12/Test-Article/"/>
    <url>/2023/04/12/Test-Article/</url>
    
    <content type="html"><![CDATA[<p>This a test article in order to check the pages</p><span id="more"></span><p><img src="https://gitee.com/wdtte/images/raw/master/202304122310891.png" alt="image-20230412231023834"></p><h3 id="Hello-Test"><a href="#Hello-Test" class="headerlink" title="Hello Test"></a>Hello Test</h3><p>This is a code block</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">package</span> com.wdte.springboot_mybatis.bean;<br><br><span class="hljs-keyword">import</span> lombok.AllArgsConstructor;<br><span class="hljs-keyword">import</span> lombok.Data;<br><span class="hljs-keyword">import</span> lombok.NoArgsConstructor;<br><span class="hljs-keyword">import</span> lombok.ToString;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Wdttee</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span> This is description of class</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@datetime</span> 19:38 2023/4/11 2023</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@NoArgsConstructor</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-meta">@ToString</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-keyword">private</span> Integer id;<br>    <span class="hljs-keyword">private</span> String username;<br>    <span class="hljs-keyword">private</span> String password;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="Fundamentals"><a href="#Fundamentals" class="headerlink" title="Fundamentals"></a>Fundamentals</h1><p>This is the first article in a series of articles about three.js. <a href="https://threejs.org/">Three.js</a> is a 3D library that tries to make it as easy as possible to get 3D content on a webpage.</p><p>Three.js is often confused with WebGL since more often than not, but not always, three.js uses WebGL to draw 3D. <a href="https://webglfundamentals.org/">WebGL is a very low-level system that only draws points, lines, and triangles</a>. To do anything useful with WebGL generally requires quite a bit of code and that is where three.js comes in. It handles stuff like scenes, lights, shadows, materials, textures, 3d math, all things that you’d have to write yourself if you were to use WebGL directly.</p><p>These tutorials assume you already know JavaScript and, for the most part they will use ES6 style. <a href="https://threejs.org/manual/en/prerequisites.html">See here for a terse list of things you’re expected to already know</a>. Most browsers that support three.js are auto-updated so most users should be able to run this code. If you’d like to make this code run on really old browsers look into a transpiler like <a href="https://babeljs.io/">Babel</a>. Of course users running really old browsers probably have machines that can’t run three.js.</p><p>When learning most programming languages the first thing people do is make the computer print <code>&quot;Hello World!&quot;</code>. For 3D one of the most common first things to do is to make a 3D cube. So let’s start with “Hello Cube!”</p><p>Before we get started let’s try to give you an idea of the structure of a three.js app. A three.js app requires you to create a bunch of objects and connect them together. Here’s a diagram that represents a small three.js app</p><p><img src="https://raw.githubusercontent.com/wdtte/image/main/202304120827809.png"></p><p>Things to notice about the diagram above.</p><ul><li><p>There is a <a href="https://threejs.org/docs/#api/en/constants/Renderer"><code>Renderer</code></a>. This is arguably the main object of three.js. You pass a <a href="https://threejs.org/docs/#api/en/scenes/Scene"><code>Scene</code></a> and a <a href="https://threejs.org/docs/#api/en/cameras/Camera"><code>Camera</code></a> to a <a href="https://threejs.org/docs/#api/en/constants/Renderer"><code>Renderer</code></a> and it renders (draws) the portion of the 3D scene that is inside the <em>frustum</em> of the camera as a 2D image to a canvas.</p></li><li><p>There is a <a href="https://threejs.org/manual/en/scenegraph.html">scenegraph</a> which is a tree like structure, consisting of various objects like a <a href="https://threejs.org/docs/#api/en/scenes/Scene"><code>Scene</code></a> object, multiple <a href="https://threejs.org/docs/#api/en/objects/Mesh"><code>Mesh</code></a> objects, <a href="https://threejs.org/docs/#api/en/lights/Light"><code>Light</code></a> objects, <a href="https://threejs.org/docs/#api/en/objects/Group"><code>Group</code></a>, <a href="https://threejs.org/docs/#api/en/core/Object3D"><code>Object3D</code></a>, and <a href="https://threejs.org/docs/#api/en/cameras/Camera"><code>Camera</code></a> objects. A <a href="https://threejs.org/docs/#api/en/scenes/Scene"><code>Scene</code></a> object defines the root of the scenegraph and contains properties like the background color and fog. These objects define a hierarchical parent&#x2F;child tree like structure and represent where objects appear and how they are oriented. Children are positioned and oriented relative to their parent. For example the wheels on a car might be children of the car so that moving and orienting the car’s object automatically moves the wheels. You can read more about this in <a href="https://threejs.org/manual/en/scenegraph.html">the article on scenegraphs</a>.</p><p>Note in the diagram <a href="https://threejs.org/docs/#api/en/cameras/Camera"><code>Camera</code></a> is half in half out of the scenegraph. This is to represent that in three.js, unlike the other objects, a <a href="https://threejs.org/docs/#api/en/cameras/Camera"><code>Camera</code></a> does not have to be in the scenegraph to function. Just like other objects, a <a href="https://threejs.org/docs/#api/en/cameras/Camera"><code>Camera</code></a>, as a child of some other object, will move and orient relative to its parent object. There is an example of putting multiple <a href="https://threejs.org/docs/#api/en/cameras/Camera"><code>Camera</code></a> objects in a scenegraph at the end of <a href="https://threejs.org/manual/en/scenegraph.html">the article on scenegraphs</a>.</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>test</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/03/01/hello-world/"/>
    <url>/2022/03/01/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Hello-Hexo"><a href="#Hello-Hexo" class="headerlink" title="Hello Hexo"></a>Hello Hexo</h2><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
